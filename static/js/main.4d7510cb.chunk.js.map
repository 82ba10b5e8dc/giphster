{"version":3,"sources":["serviceWorker.ts","support/contexts/modal/index.tsx","support/store/index.ts","components/Root/index.tsx","support/api/index.ts","support/constants.ts","components/Search/index.tsx","components/Item/index.tsx","components/Grid/index.tsx","components/Modal/index.tsx","containers/App/index.tsx","index.tsx"],"names":["Boolean","window","location","hostname","match","ModalContext","createContext","show","gif","hide","ModalManager","children","useState","item","setItem","Provider","value","useModal","useContext","ADD","SET","add","payload","type","set","createStore","state","action","Root","store","displayName","BASE_PARAMS","URLSearchParams","append","process","read","options","a","async","params","offset","query","path","fetch","response","ok","Error","json","Search","onChange","setValue","className","placeholder","event","target","Item","status","setStatus","pendingClassname","onClick","alt","title","onLoad","src","images","downsized","url","Grid","elements","items","map","key","id","Modal","useEffect","document","body","style","overflow","original","App","dispatch","useDispatch","setQuery","setOffset","useSelector","handleScroll","useCallback","innerHeight","scrollY","scrollHeight","handleSearch","debounce","api","results","data","fetchData","addEventListener","removeEventListener","description","ReactDOM","render","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.4d7510cb.chunk.js","sourcesContent":["// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React, { FC, createContext, useContext, useState } from 'react'\n\nimport { Gif } from 'support/types'\n\ninterface Context {\n  item?: Gif;\n  show: (gif: Gif) => void;\n  hide: () => void;\n}\n\nexport const ModalContext = createContext<Context>({\n  show: (gif) => {},\n  hide: () => {}\n})\n\nexport const ModalManager: FC = ({ children }) => {\n  const [item, setItem] = useState()\n\n  const show = (gif: Gif) => setItem(gif)\n\n  const hide = () => setItem(null)\n\n  return (\n    <ModalContext.Provider value={{show, hide, item}}>\n      {children}\n    </ModalContext.Provider>\n  )\n}\n\nexport function useModal () {\n  return useContext(ModalContext)\n}\n","import { createStore } from 'redux'\n\nimport { Action, Gif } from 'support/types'\n\nconst ADD = 'gifs/ADD'\nconst SET = 'gifs/SET'\n\n/**\n * adds the array of gifs to the reducer state at the provided key\n */\n\nexport const add = (payload: Gif[]) => ({\n  type: ADD,\n  payload\n})\n\n/**\n * sets the value of \n */\n\nexport const set = (payload: Gif[]) => ({\n  type: SET,\n  payload\n})\n\n/**\n * the reducer adds a key for each query made by the user so that the session\n * can save some data in case they type that query again\n */\n\nconst reducer = (state: Gif[] = [], action: Action) => {\n  switch (action.type) {\n    case ADD:\n      return [...state, ...action.payload]\n\n    case SET:\n      return action.payload\n\n    default:\n      return state\n  }\n}\n\nconst initialState: Gif[] = []\n\nexport default createStore(reducer, initialState)\n","import React, { FC } from 'react'\nimport { Provider } from 'react-redux'\n\nimport { ModalManager } from 'support/contexts/modal'\nimport store from 'support/store'\n\nconst Root: FC = ({ children }) => (\n  <ModalManager>\n    <Provider store={store}>\n      {children}\n    </Provider>\n  </ModalManager>\n)\n\nRoot.displayName = 'Root'\n\nexport default Root\n","import { API_URL, PAGE_SIZE } from 'support/constants'\n\nconst BASE_PARAMS = new URLSearchParams()\n\nBASE_PARAMS.append('api_key', `${process.env.REACT_APP_API_KEY}`)\nBASE_PARAMS.append('limit', `${PAGE_SIZE}`)\n\n/**\n * fetches either the trending or search endpoint for giphy based on whether\n * we have a query key in the options\n */\n\ninterface Options {\n  offset: number;\n  query?: string;\n}\n\nexport const read = async (options: Options) => {\n  const params = new URLSearchParams(BASE_PARAMS)\n  params.append('offset', `${options.offset}`)\n  params.append('q', `${options.query || ''}`)\n\n  const path = options.query\n    ? `gifs/search`\n    : `gifs/trending`\n\n  try {\n    const response = await fetch(`${API_URL}${path}?${params}`)\n\n    if (!response.ok) {\n      throw new Error('Failed to fetch')\n    }\n\n    const json = await response.json()\n\n    return json\n  } catch (error) {\n    throw new Error('failed')\n  }\n}\n","export const PAGE_SIZE = 12\n\nexport const API_URL = 'https://api.giphy.com/v1/'\n","import React, { FC, ChangeEvent, useState } from 'react'\n\nimport './styles.css'\n\ninterface Props {\n  onChange: (value: string) => void;\n}\n\nconst Search: FC<Props> = ({ onChange }) => {\n  const [value, setValue] = useState('')\n\n  const handleChange = (event: ChangeEvent<HTMLInputElement>) => {\n    setValue(event.target.value)\n    onChange(event.target.value)\n  }\n\n  return (\n    <input\n      className='search'\n      placeholder='Search ... e.g. Star Trek'\n      type='text'\n      value={value}\n      onChange={handleChange}\n    />\n  )\n}\n\nexport default Search\n","import React, { FC, useState } from 'react'\n\nimport { useModal } from 'support/contexts/modal'\n\nimport './styles.css';\n\ninterface Props {\n  gif: any;\n}\n\nconst Item: FC<Props> = ({ gif }) => {\n  const { show } = useModal()\n  const [status, setStatus] = useState('pending')\n\n  /**\n   * on clicking this item, we'll set the current modal gif to it, this will\n   * trigger the modal component to render\n   */\n\n  const handleClick = () => show(gif)\n\n  /**\n   *\n   */\n\n  const handleLoad = () => setStatus('success')\n\n  const pendingClassname = status === 'pending'\n    ? 'item__pending--visible'\n    : 'item__pending--hidden'\n\n  return (\n    <div onClick={handleClick} className='item'>\n      <div className='item__container'>\n        <img\n          className='item__image'\n          alt={gif.title}\n          onLoad={handleLoad}\n          src={gif.images.downsized.url}\n        />\n\n        <div className={`${pendingClassname} item__pending`}>\n          <div className='dot-flashing' />\n        </div>\n      </div>\n    </div>\n  )\n}\n\nexport default Item\n","import React, { FC } from 'react'\n\nimport Item from '../Item'\nimport './styles.css'\n\nimport { Gif } from 'support/types'\n\ninterface Props {\n  items: Gif[]\n}\n\nconst Grid: FC<Props> = ({ items }) => {\n  const elements = items.map((item: any) => <Item key={item.id} gif={item} />)\n\n  return (\n    <div className='grid'>\n      {elements}\n    </div>\n  )\n}\n\nexport default Grid\n","import React, { FC, useEffect } from 'react'\n\nimport { useModal } from 'support/contexts/modal'\n\nimport './styles.css'\n\nconst Modal: FC = () => {\n  const { hide, item } = useModal()\n\n  /**\n   * we'll check when the item is set and disable scrolling so the user doesn't\n   * fetch more gifs in the background while they are viewing\n   */\n\n  useEffect(() => {\n    document.body.style.overflow = item\n      ? 'hidden'\n      : 'auto'\n  }, [item])\n\n  if (!item) {\n    return null\n  }\n\n  return (\n    <div onClick={hide} className='modal'>\n      <div className='modal__content'>\n        <img\n          className='modal__image'\n          src={item.images.original.url}\n          alt={item.title}\n        />\n      </div>\n    </div>\n  )\n}\n\nModal.displayName = 'Modal'\n\nexport default Modal\n","import 'normalize.css'\n\nimport debounce from 'debounce'\nimport React, { FC, useCallback, useEffect, useState } from 'react';\nimport { useDispatch, useSelector } from 'react-redux'\n\nimport * as api from 'support/api'\nimport { add, set } from 'support/store'\n\nimport Search from 'components/Search'\nimport Grid from 'components/Grid'\nimport Modal from 'components/Modal'\nimport { Gif } from 'support/types'\n\nimport './styles.css'\n\nconst PAGE_SIZE = 12\n\nconst App: FC = () => {\n  const dispatch = useDispatch()\n  const [query, setQuery] = useState('')\n  const [offset, setOffset] = useState(0)\n  const items = useSelector((state: Gif[]) => state)\n\n  /**\n   * handler for the scroll event which updates the offset by adding one page\n   * size of elements\n   */\n\n  const handleScroll = useCallback(() => {\n    if ((window.innerHeight + window.scrollY) >= document.body.scrollHeight) {\n      return setOffset(offset + PAGE_SIZE)\n    }\n  }, [offset])\n\n  /**\n   * resets the offset and sets the query state to the value provided\n   */\n\n  const handleSearch = debounce((value: string) => {\n    setOffset(0)\n    setQuery(value)\n  }, 500)\n\n  /**\n   * on change of the query or offset fetches a set of data and dispatches\n   * an action to set the redux state with the new value\n   */\n\n  useEffect(() => {\n    const fetchData = async () => {\n      const results = await api.read({\n        offset,\n        query\n      })\n\n      const action = offset === 0\n        ? set\n        : add\n\n      dispatch(action(results.data))\n    }\n\n    fetchData()\n  }, [query, offset, dispatch])\n\n  /**\n   * attaches an event listener to the window to capture when the user scrolls\n   * to the bottom of the page. then updates the offset to a new page that\n   * triggers the fetch for more data\n   */\n\n  useEffect(() => {\n    window.addEventListener('scroll', handleScroll);\n    return () => window.removeEventListener('scroll', handleScroll);\n  }, [handleScroll])\n\n  const description = query\n    ? `Displaying Results for \"${query}\"`\n    : `Displaying results for what's currently trending`\n\n  return (\n    <div className='app'>\n      <header className='app__header'>\n        <h1 className='app__title'>\n          Giphster\n        </h1>\n\n        <div className='app__search'>\n          <Search onChange={handleSearch} />\n        </div>\n      </header>\n\n      <div className='app__content'>\n        <p className='caption app__description'>\n          {description}\n        </p>\n\n        <Grid items={items} />\n      </div>\n\n      <Modal />\n    </div>\n  )\n}\n\nApp.displayName = 'App'\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\n\nimport * as serviceWorker from './serviceWorker';\nimport Root from './components/Root'\nimport App from './containers/App';\n\nReactDOM.render(\n  <Root>\n    <App />\n  </Root>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}